// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the GeometryGraph Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using GeometryGraph.Runtime.Attributes;
using GeometryGraph.Runtime.AttributeSystem;
using GeometryGraph.Runtime.Geometry;
using GeometryGraph.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using Unity.Mathematics;
using UnityEngine;

namespace GeometryGraph.Runtime.Graph {
    [SourceClass("GeometryGraph.Runtime::GeometryGraph.Runtime.Graph::ScalePointNode")]
    public partial class ScalePointNode : RuntimeNode {
        public RuntimePort InputPort { get; }
        public RuntimePort VectorPort { get; }
        public RuntimePort ScalarPort { get; }
        public RuntimePort AttributeNamePort { get; }
        public RuntimePort ResultPort { get; }

        public ScalePointNode(string guid) : base(guid) {
            InputPort = RuntimePort.Create(PortType.Geometry, PortDirection.Input, this);
            VectorPort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            ScalarPort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            AttributeNamePort = RuntimePort.Create(PortType.String, PortDirection.Input, this);
            ResultPort = RuntimePort.Create(PortType.Geometry, PortDirection.Output, this);
        }

        public void UpdateInput(GeometryData newValue) {
            Input = newValue;
            Calculate();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateVector(float3 newValue) {
            if(math.distancesq(Vector, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
            Vector = newValue;
            Calculate();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateScalar(float newValue) {
            if(Math.Abs(Scalar - newValue) < Constants.FLOAT_TOLERANCE) return;
            Scalar = newValue;
            Calculate();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateAttributeName(string newValue) {
            if(string.Equals(AttributeName, newValue, StringComparison.InvariantCulture)) return;
            AttributeName = newValue;
            Calculate();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateMode(ScalePointNode_Mode newValue) {
            if(Mode == newValue) return;
            Mode = newValue;
            Calculate();
            NotifyPortValueChanged(ResultPort);
        }

        protected override object GetValueForPort(RuntimePort port) {
            if (port == ResultPort) return Result;
            return null;
        }

        protected override void OnPortValueChanged(Connection connection, RuntimePort port) {
            if (port == ResultPort) return;
            if (port == InputPort) {
                var newValue = GetValue(connection, Input);
                Input = newValue;
                Calculate();
                NotifyPortValueChanged(ResultPort);
            } else if (port == VectorPort) {
                var newValue = GetValue(connection, Vector);
                if(math.distancesq(Vector, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
                Vector = newValue;
                Calculate();
                NotifyPortValueChanged(ResultPort);
            } else if (port == ScalarPort) {
                var newValue = GetValue(connection, Scalar);
                if(Math.Abs(Scalar - newValue) < Constants.FLOAT_TOLERANCE) return;
                Scalar = newValue;
                Calculate();
                NotifyPortValueChanged(ResultPort);
            } else if (port == AttributeNamePort) {
                var newValue = GetValue(connection, AttributeName);
                if(string.Equals(AttributeName, newValue, StringComparison.InvariantCulture)) return;
                AttributeName = newValue;
                Calculate();
                NotifyPortValueChanged(ResultPort);
            }
        }

        public override string GetCustomData() {
            return new JArray {
                JsonConvert.SerializeObject(Vector, float3Converter.Converter),
                Scalar,
                AttributeName,
                (int)Mode,
            }.ToString(Formatting.None);
        }

        public override void SetCustomData(string data) {
            JArray array = JArray.Parse(data);
            Vector = JsonConvert.DeserializeObject<float3>(array.Value<string>(0), float3Converter.Converter);
            Scalar = array.Value<float>(1);
            AttributeName = array.Value<string>(2);
            Mode = (ScalePointNode_Mode) array.Value<int>(3);

            Calculate();
            NotifyPortValueChanged(ResultPort);
        }
    }
}