// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the GeometryGraph Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using GeometryGraph.Runtime.Attributes;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using Unity.Mathematics;

namespace GeometryGraph.Runtime.Graph {
    [SourceClass("GeometryGraph.Runtime::GeometryGraph.Runtime.Graph::FloatMathNode")]
    public partial class FloatMathNode : RuntimeNode {
        public RuntimePort XPort { get; }
        public RuntimePort YPort { get; }
        public RuntimePort TolerancePort { get; }
        public RuntimePort ExtraPort { get; }
        public RuntimePort ResultPort { get; }

        public FloatMathNode(string guid) : base(guid) {
            XPort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            YPort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            TolerancePort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            ExtraPort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            ResultPort = RuntimePort.Create(PortType.Float, PortDirection.Output, this);
        }

        public void UpdateX(float newValue) {
            if(Math.Abs(X - newValue) < Constants.FLOAT_TOLERANCE) return;
            X = newValue;
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateY(float newValue) {
            if(Math.Abs(Y - newValue) < Constants.FLOAT_TOLERANCE) return;
            Y = newValue;
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateTolerance(float newValue) {
            if(Math.Abs(Tolerance - newValue) < Constants.FLOAT_TOLERANCE) return;
            Tolerance = newValue;
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateExtra(float newValue) {
            if(Math.Abs(Extra - newValue) < Constants.FLOAT_TOLERANCE) return;
            Extra = newValue;
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateOperation(FloatMathNode_Operation newValue) {
            if(Operation == newValue) return;
            Operation = newValue;
            NotifyPortValueChanged(ResultPort);
        }

        protected override object GetValueForPort(RuntimePort port) {
            if (port == ResultPort) {
                return Operation switch {
                    FloatMathNode_Operation.Add => X + Y,
                    FloatMathNode_Operation.Subtract => X - Y,
                    FloatMathNode_Operation.Multiply => X * Y,
                    FloatMathNode_Operation.Divide => X / Y,
                    FloatMathNode_Operation.Power => math.pow(X, Y),
                    FloatMathNode_Operation.Logarithm => MathF.Log(X, Y),
                    FloatMathNode_Operation.SquareRoot => math.sqrt(X),
                    FloatMathNode_Operation.InverseSquareRoot => math.rsqrt(X),
                    FloatMathNode_Operation.Absolute => math.abs(X),
                    FloatMathNode_Operation.Exponent => math.exp(X),
    
                    FloatMathNode_Operation.Minimum => math.min(X, Y),
                    FloatMathNode_Operation.Maximum => math.max(X, Y),
                    FloatMathNode_Operation.LessThan => X < Y ? 1.0f : 0.0f,
                    FloatMathNode_Operation.GreaterThan => X > Y ? 1.0f : 0.0f,
                    FloatMathNode_Operation.Sign => X < 0 ? -1.0f : X == 0.0f ? 0.0f : 1.0f,
                    FloatMathNode_Operation.Compare => math.abs(X - Y) < Tolerance ? 1.0f : 0.0f,
                    FloatMathNode_Operation.SmoothMinimum => math_ext.smooth_min(X, Y, Tolerance),
                    FloatMathNode_Operation.SmoothMaximum => math_ext.smooth_max(X, Y, Tolerance),
    
                    FloatMathNode_Operation.Round => math.round(X),
                    FloatMathNode_Operation.Floor => math.floor(X),
                    FloatMathNode_Operation.Ceil => math.ceil(X),
                    FloatMathNode_Operation.Truncate => (int)X,
                    FloatMathNode_Operation.Fraction => X - (int)X,
                    FloatMathNode_Operation.Modulo => MathF.IEEERemainder(X, Y),
                    FloatMathNode_Operation.Wrap => X = math_ext.wrap(X, Y, Extra),
                    FloatMathNode_Operation.Snap => math.round(X / Y) * Y,
    
                    FloatMathNode_Operation.Sine => math.sin(X),
                    FloatMathNode_Operation.Cosine => math.cos(X),
                    FloatMathNode_Operation.Tangent => math.tan(X),
                    FloatMathNode_Operation.Arcsine => math.asin(X),
                    FloatMathNode_Operation.Arccosine => math.acos(X),
                    FloatMathNode_Operation.Arctangent => math.atan(X),
                    FloatMathNode_Operation.Atan2 => math.atan2(X, Y),
                    FloatMathNode_Operation.ToRadians => math.radians(X),
                    FloatMathNode_Operation.ToDegrees => math.degrees(X),
                    FloatMathNode_Operation.Lerp => math.lerp(X, Y, Extra),
                    _ => throw new ArgumentOutOfRangeException()
                };
            }
            return null;
        }

        protected override void OnPortValueChanged(Connection connection, RuntimePort port) {
            if (port == ResultPort) return;
            if (port == XPort) {
                var newValue = GetValue(connection, X);
                if(Math.Abs(X - newValue) < Constants.FLOAT_TOLERANCE) return;
                X = newValue;
                NotifyPortValueChanged(ResultPort);
            } else if (port == YPort) {
                var newValue = GetValue(connection, Y);
                if(Math.Abs(Y - newValue) < Constants.FLOAT_TOLERANCE) return;
                Y = newValue;
                NotifyPortValueChanged(ResultPort);
            } else if (port == TolerancePort) {
                var newValue = GetValue(connection, Tolerance);
                if(Math.Abs(Tolerance - newValue) < Constants.FLOAT_TOLERANCE) return;
                Tolerance = newValue;
                NotifyPortValueChanged(ResultPort);
            } else if (port == ExtraPort) {
                var newValue = GetValue(connection, Extra);
                if(Math.Abs(Extra - newValue) < Constants.FLOAT_TOLERANCE) return;
                Extra = newValue;
                NotifyPortValueChanged(ResultPort);
            }
        }

        public override string GetCustomData() {
            return new JArray {
                X,
                Y,
                Tolerance,
                Extra,
                (int)Operation,
            }.ToString(Formatting.None);
        }

        public override void SetCustomData(string data) {
            JArray array = JArray.Parse(data);
            X = array.Value<float>(0);
            Y = array.Value<float>(1);
            Tolerance = array.Value<float>(2);
            Extra = array.Value<float>(3);
            Operation = (FloatMathNode_Operation) array.Value<int>(4);

            NotifyPortValueChanged(ResultPort);
        }
    }
}