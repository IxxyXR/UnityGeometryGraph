// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the GeometryGraph Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using GeometryGraph.Runtime.Attributes;
using GeometryGraph.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using Unity.Mathematics;

namespace GeometryGraph.Runtime.Graph {
    [SourceClass("GeometryGraph.Runtime::GeometryGraph.Runtime.Graph::VectorMathNode")]
    public partial class VectorMathNode : RuntimeNode {
        public RuntimePort XPort { get; }
        public RuntimePort YPort { get; }
        public RuntimePort WrapMaxPort { get; }
        public RuntimePort IORPort { get; }
        public RuntimePort ScalePort { get; }
        public RuntimePort DistancePort { get; }
        public RuntimePort VectorResultPort { get; }
        public RuntimePort FloatResultPort { get; }

        public VectorMathNode(string guid) : base(guid) {
            XPort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            YPort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            WrapMaxPort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            IORPort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            ScalePort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            DistancePort = RuntimePort.Create(PortType.Float, PortDirection.Input, this);
            VectorResultPort = RuntimePort.Create(PortType.Vector, PortDirection.Output, this);
            FloatResultPort = RuntimePort.Create(PortType.Float, PortDirection.Output, this);
        }

        public void UpdateX(float3 newValue) {
            X = newValue;
            NotifyPortValueChanged(VectorResultPort);
            NotifyPortValueChanged(FloatResultPort);
        }

        public void UpdateY(float3 newValue) {
            Y = newValue;
            NotifyPortValueChanged(VectorResultPort);
            NotifyPortValueChanged(FloatResultPort);
        }

        public void UpdateWrapMax(float3 newValue) {
            WrapMax = newValue;
            NotifyPortValueChanged(VectorResultPort);
            NotifyPortValueChanged(FloatResultPort);
        }

        public void UpdateIOR(float newValue) {
            if(Math.Abs(IOR - newValue) < Constants.FLOAT_TOLERANCE) return;
            IOR = newValue;
            NotifyPortValueChanged(VectorResultPort);
        }

        public void UpdateScale(float newValue) {
            if(Math.Abs(Scale - newValue) < Constants.FLOAT_TOLERANCE) return;
            Scale = newValue;
            NotifyPortValueChanged(VectorResultPort);
        }

        public void UpdateDistance(float newValue) {
            if(Math.Abs(Distance - newValue) < Constants.FLOAT_TOLERANCE) return;
            Distance = newValue;
            NotifyPortValueChanged(VectorResultPort);
        }

        public void UpdateOperation(VectorMathNode_Operation newValue) {
            if(Operation == newValue) return;
            Operation = newValue;
            NotifyPortValueChanged(VectorResultPort);
            NotifyPortValueChanged(FloatResultPort);
        }

        protected override object GetValueForPort(RuntimePort port) {
            if (port == VectorResultPort) return CalculateVector();
            if (port == FloatResultPort) return CalculateFloat();
            return null;
        }

        protected override void OnPortValueChanged(Connection connection, RuntimePort port) {
            if (port == VectorResultPort || port == FloatResultPort) return;
            if (port == XPort) {
                var newValue = GetValue(connection, X);
                X = newValue;
                NotifyPortValueChanged(VectorResultPort);
                NotifyPortValueChanged(FloatResultPort);
            } else if (port == YPort) {
                var newValue = GetValue(connection, Y);
                Y = newValue;
                NotifyPortValueChanged(VectorResultPort);
                NotifyPortValueChanged(FloatResultPort);
            } else if (port == WrapMaxPort) {
                var newValue = GetValue(connection, WrapMax);
                WrapMax = newValue;
                NotifyPortValueChanged(VectorResultPort);
                NotifyPortValueChanged(FloatResultPort);
            } else if (port == IORPort) {
                var newValue = GetValue(connection, IOR);
                if(Math.Abs(IOR - newValue) < Constants.FLOAT_TOLERANCE) return;
                IOR = newValue;
                NotifyPortValueChanged(VectorResultPort);
            } else if (port == ScalePort) {
                var newValue = GetValue(connection, Scale);
                if(Math.Abs(Scale - newValue) < Constants.FLOAT_TOLERANCE) return;
                Scale = newValue;
                NotifyPortValueChanged(VectorResultPort);
            } else if (port == DistancePort) {
                var newValue = GetValue(connection, Distance);
                if(Math.Abs(Distance - newValue) < Constants.FLOAT_TOLERANCE) return;
                Distance = newValue;
                NotifyPortValueChanged(VectorResultPort);
            }
        }

        public override string GetCustomData() {
            return new JArray {
                JsonConvert.SerializeObject(X, float3Converter.Converter),
                JsonConvert.SerializeObject(Y, float3Converter.Converter),
                JsonConvert.SerializeObject(WrapMax, float3Converter.Converter),
                IOR,
                Scale,
                Distance,
                (int)Operation,
            }.ToString(Formatting.None);
        }

        public override void SetCustomData(string data) {
            JArray array = JArray.Parse(data);
            X = JsonConvert.DeserializeObject<float3>(array.Value<string>(0), float3Converter.Converter);
            Y = JsonConvert.DeserializeObject<float3>(array.Value<string>(1), float3Converter.Converter);
            WrapMax = JsonConvert.DeserializeObject<float3>(array.Value<string>(2), float3Converter.Converter);
            IOR = array.Value<float>(3);
            Scale = array.Value<float>(4);
            Distance = array.Value<float>(5);
            Operation = (VectorMathNode_Operation) array.Value<int>(6);

            NotifyPortValueChanged(VectorResultPort);
            NotifyPortValueChanged(FloatResultPort);
        }
    }
}