// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the GeometryGraph Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using GeometryGraph.Runtime.Attributes;
using GeometryGraph.Runtime.Curve;
using GeometryGraph.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Collections.Generic;
using Unity.Mathematics;

namespace GeometryGraph.Runtime.Graph {
    [SourceClass("GeometryGraph.Runtime::GeometryGraph.Runtime.Graph::TransformCurveNode")]
    public partial class TransformCurveNode : RuntimeNode {
        public RuntimePort InputPort { get; }
        public RuntimePort IsClosedPort { get; }
        public RuntimePort TranslationPort { get; }
        public RuntimePort RotationPort { get; }
        public RuntimePort ScalePort { get; }
        public RuntimePort ResultPort { get; }

        public TransformCurveNode(string guid) : base(guid) {
            InputPort = RuntimePort.Create(PortType.Curve, PortDirection.Input, this);
            IsClosedPort = RuntimePort.Create(PortType.Boolean, PortDirection.Input, this);
            TranslationPort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            RotationPort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            ScalePort = RuntimePort.Create(PortType.Vector, PortDirection.Input, this);
            ResultPort = RuntimePort.Create(PortType.Curve, PortDirection.Output, this);
        }

        public void UpdateIsClosed(bool newValue) {
            if(IsClosed == newValue) return;
            IsClosed = newValue;
            CalculateResult();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateTranslation(float3 newValue) {
            if(math.distancesq(Translation, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
            Translation = newValue;
            CalculateResult();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateRotation(float3 newValue) {
            if(math.distancesq(Rotation, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
            Rotation = newValue;
            CalculateResult();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateScale(float3 newValue) {
            if(math.distancesq(Scale, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
            Scale = newValue;
            CalculateResult();
            NotifyPortValueChanged(ResultPort);
        }

        public void UpdateChangeClosed(bool newValue) {
            if(ChangeClosed == newValue) return;
            ChangeClosed = newValue;
            CalculateResult();
            NotifyPortValueChanged(ResultPort);
        }

        protected override object GetValueForPort(RuntimePort port) {
            if (port == ResultPort) return Result ?? CurveData.Empty;
            return null;
        }

        protected override void OnPortValueChanged(Connection connection, RuntimePort port) {
            if (port == ResultPort) return;
            if (port == InputPort) {
                Input = GetValue(connection, (CurveData)null);
                CalculateResult();
                NotifyPortValueChanged(ResultPort);
            } else if (port == IsClosedPort) {
                var newValue = GetValue(connection, IsClosed);
                if(IsClosed == newValue) return;
                IsClosed = newValue;
                if (Result != null) {
                    Result.IsClosed = IsClosed;
                } else {
                    CalculateResult();
                }
                NotifyPortValueChanged(ResultPort);
            } else if (port == TranslationPort) {
                var newValue = GetValue(connection, Translation);
                if(math.distancesq(Translation, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
                Translation = newValue;
                CalculateResult();
                NotifyPortValueChanged(ResultPort);
            } else if (port == RotationPort) {
                var newValue = GetValue(connection, Rotation);
                if(math.distancesq(Rotation, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
                Rotation = newValue;
                CalculateResult();
                NotifyPortValueChanged(ResultPort);
            } else if (port == ScalePort) {
                var newValue = GetValue(connection, Scale);
                if(math.distancesq(Scale, newValue) < Constants.FLOAT_TOLERANCE * Constants.FLOAT_TOLERANCE) return;
                Scale = newValue;
                CalculateResult();
                NotifyPortValueChanged(ResultPort);
            }
        }

        public override string GetCustomData() {
            return new JArray {
                IsClosed ? 1 : 0,
                JsonConvert.SerializeObject(Translation, float3Converter.Converter),
                JsonConvert.SerializeObject(Rotation, float3Converter.Converter),
                JsonConvert.SerializeObject(Scale, float3Converter.Converter),
                ChangeClosed ? 1 : 0,
            }.ToString(Formatting.None);
        }

        public override void SetCustomData(string data) {
            JArray array = JArray.Parse(data);
            IsClosed = array.Value<int>(0) == 1;
            Translation = JsonConvert.DeserializeObject<float3>(array.Value<string>(1), float3Converter.Converter);
            Rotation = JsonConvert.DeserializeObject<float3>(array.Value<string>(2), float3Converter.Converter);
            Scale = JsonConvert.DeserializeObject<float3>(array.Value<string>(3), float3Converter.Converter);
            ChangeClosed = array.Value<int>(4) == 1;

            CalculateResult();
            NotifyPortValueChanged(ResultPort);
        }
    }
}